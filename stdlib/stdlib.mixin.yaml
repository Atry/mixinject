# MIXIN Standard Library
# Church-encoded data types and polymorphic operations
# Demonstrating Expression Problem solution via 2D modular composition
#
# No wrapper key: the file name "stdlib" provides the namespace via selfName.
# Internal references omit the "stdlib" prefix since the file name provides the namespace.

# Layer 1: Abstract Structures

abstract:
  Semigroup:
    element_type: {}
    Combine:
      left: {}
      right: {}
      result: {}

# Layer 2: Core Types (observer interfaces)

types:
  Boolean:
    on_true: {}
    on_false: {}
    result: {}

  Nat:
    successor:
      argument: {}
      result: {}
    zero: {}
    result: {}

  BinNat:
    on_odd:
      argument: {}
      result: {}
    on_even:
      argument: {}
      result: {}
    on_zero: {}
    result: {}

  List:
    on_nil:
      result: {}
    on_cons:
      item: {}
      rest: {}
      result: {}
    result: {}

# Constructors

constructors:
  "True":
    - [types, Boolean]
    - result:
        - ["True", [on_true]]

  "False":
    - [types, Boolean]
    - result:
        - ["False", [on_false]]

  Zero:
    - [types, Nat]
    - result:
        - [Zero, [zero]]

  Succ:
    - [types, Nat]
    - predecessor:
        - [types, Nat]
      successor:
        - [Succ, [successor]]
        - argument:
            - [Succ, [predecessor]]
          result: {}
      result:
        - [Succ, [successor, result]]

  BinNatZero:
    - [types, BinNat]
    - result:
        - [BinNatZero, [on_zero]]

  BinNatOdd:
    - [types, BinNat]
    - operand:
        - [types, BinNat]
      on_odd:
        - [BinNatOdd, [on_odd]]
        - argument:
            - [BinNatOdd, [operand]]
      result:
        - [BinNatOdd, [on_odd, result]]

  BinNatEven:
    - [types, BinNat]
    - operand:
        - [types, BinNat]
      on_even:
        - [BinNatEven, [on_even]]
        - argument:
            - [BinNatEven, [operand]]
      result:
        - [BinNatEven, [on_even, result]]

  ListNil:
    - [types, List]
    - result:
        - [ListNil, [on_nil, result]]

  ListCons:
    - [types, List]
    - item: {}
      rest:
        - [types, List]
      on_cons:
        - [ListCons, [on_cons]]
        - item:
            - [ListCons, [item]]
          rest:
            - [ListCons, [rest]]
      result:
        - [ListCons, [on_cons, result]]

# Layer 3: Type-Specific Operations

boolean:
  equality:
    BooleanEquality:
      - [types, Boolean]
      - left:
          - [types, Boolean]
        right:
          - [types, Boolean]
        _applied_left:
          - [left]
          - on_true:
              - [right]
              - on_true:
                  result:
                    - [constructors, "True"]
                on_false:
                  result:
                    - [constructors, "False"]
            on_false:
              - [right]
              - on_true:
                  result:
                    - [constructors, "False"]
                on_false:
                  result:
                    - [constructors, "True"]
        result:
          - [_applied_left, result]

  operations:
    BooleanAnd:
      - [types, Boolean]
      - left:
          - [types, Boolean]
        right:
          - [types, Boolean]
        _applied_left:
          - [left]
          - on_true:
              - [right]
            on_false:
              - [constructors, "False"]
        result:
          - [_applied_left, result]

    BooleanOr:
      - [types, Boolean]
      - left:
          - [types, Boolean]
        right:
          - [types, Boolean]
        _applied_left:
          - [left]
          - on_true:
              - [constructors, "True"]
            on_false:
              - [right]
        result:
          - [_applied_left, result]

  semigroups:
    BooleanAndSemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, Boolean]
        Combine:
          left:
            - [types, Boolean]
          right:
            - [types, Boolean]
          result:
            - [boolean, [operations, BooleanAnd]]
            - left:
                - [BooleanAndSemigroup, [Combine, left]]
              right:
                - [BooleanAndSemigroup, [Combine, right]]

    BooleanOrSemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, Boolean]
        Combine:
          left:
            - [types, Boolean]
          right:
            - [types, Boolean]
          result:
            - [boolean, [operations, BooleanOr]]
            - left:
                - [BooleanOrSemigroup, [Combine, left]]
              right:
                - [BooleanOrSemigroup, [Combine, right]]

nat:
  equality:
    # TODO: Implement recursive equality (requires fixpoint support)
    NatEquality:
      - [types, Boolean]
      - left:
          - [types, Nat]
        right:
          - [types, Nat]
        result:
          - [constructors, "True"]

  arithmetic:
    # NatAdd: Church-encoded addition using fold pattern (non-recursive)
    # add(augend, addend)(s, z) = augend(s, addend(s, z))
    NatAdd:
      - [types, Nat]
      - augend:
          - [types, Nat]
        addend:
          - [types, Nat]
        _applied_addend:
          - [NatAdd, [addend]]
          - successor:
              - [NatAdd, [successor]]
            zero:
              - [NatAdd, [zero]]
        _applied_augend:
          - [NatAdd, [augend]]
          - successor:
              - [NatAdd, [successor]]
            zero:
              - [_applied_addend, result]
        result:
          - [_applied_augend, result]

    # NatMultiply: Church-encoded multiplication using fold pattern (non-recursive)
    # multiply(multiplicand, multiplier)(s, z) = multiplicand(multiplier(s), z)
    NatMultiply:
      - [types, Nat]
      - multiplicand:
          - [types, Nat]
        multiplier:
          - [types, Nat]
        # _multiplier_applied folds multiplier with NatMultiply's successor
        # Effectively: "apply s multiplier-many times"
        _multiplier_applied:
          - [NatMultiply, [multiplier]]
          - successor:
              - [NatMultiply, [successor]]
            zero:
              - [NatMultiply, [zero]]
        # Fold multiplicand where each successor step applies _multiplier_applied
        _applied_multiplicand:
          - [NatMultiply, [multiplicand]]
          - successor:
              argument: {}
              result:
                - [_multiplier_applied]
                - zero:
                    - [_applied_multiplicand, [successor, argument]]
            zero:
              - [NatMultiply, [zero]]
        result:
          - [_applied_multiplicand, result]

  semigroups:
    NatAddSemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, Nat]
        Combine:
          left:
            - [types, Nat]
          right:
            - [types, Nat]
          result:
            - [nat, [arithmetic, NatAdd]]
            - augend:
                - [NatAddSemigroup, [Combine, left]]
              addend:
                - [NatAddSemigroup, [Combine, right]]

    NatMultiplySemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, Nat]
        Combine:
          left:
            - [types, Nat]
          right:
            - [types, Nat]
          result:
            - [nat, [arithmetic, NatMultiply]]
            - multiplicand:
                - [NatMultiplySemigroup, [Combine, left]]
              multiplier:
                - [NatMultiplySemigroup, [Combine, right]]

binnat:
  equality:
    # TODO: Implement recursive equality (requires fixpoint support)
    BinNatEquality:
      - [types, Boolean]
      - left:
          - [types, BinNat]
        right:
          - [types, BinNat]
        result:
          - [constructors, "True"]

  arithmetic:
    # TODO: Implement BinNat addition (requires recursive carry propagation)
    BinNatAdd:
      - [types, BinNat]
      - augend:
          - [types, BinNat]
        addend:
          - [types, BinNat]
        result:
          - [constructors, BinNatZero]

    # TODO: Implement BinNat multiplication (requires recursive definition)
    BinNatMultiply:
      - [types, BinNat]
      - multiplicand:
          - [types, BinNat]
        multiplier:
          - [types, BinNat]
        result:
          - [constructors, BinNatZero]

  semigroups:
    BinNatAddSemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, BinNat]
        Combine:
          left:
            - [types, BinNat]
          right:
            - [types, BinNat]
          result:
            - [binnat, [arithmetic, BinNatAdd]]
            - augend:
                - [BinNatAddSemigroup, [Combine, left]]
              addend:
                - [BinNatAddSemigroup, [Combine, right]]

    BinNatMultiplySemigroup:
      - [abstract, Semigroup]
      - element_type:
          - [types, BinNat]
        Combine:
          left:
            - [types, BinNat]
          right:
            - [types, BinNat]
          result:
            - [binnat, [arithmetic, BinNatMultiply]]
            - multiplicand:
                - [BinNatMultiplySemigroup, [Combine, left]]
              multiplier:
                - [BinNatMultiplySemigroup, [Combine, right]]

# Layer 4: Polymorphic Operations

algorithms:
  comparison:
    PolyEquality:
      equality_operator: {}
      left: {}
      right: {}
      result:
        - [algorithms, [comparison, PolyEquality, equality_operator]]
        - left:
            - [algorithms, [comparison, PolyEquality, left]]
          right:
            - [algorithms, [comparison, PolyEquality, right]]

  # TODO: Implement Fold, Sum, and Product (require recursive definitions
  # and snapshot system support for cycle detection).
